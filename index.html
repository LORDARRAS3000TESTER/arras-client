<!doctype html>
<html lang=en-US>
    <title>arras.io</title>
    <meta charset=utf-8>
    <meta name=description content="Level up and gain score by shooting at other players and bosses while keeping yourself alive! Play the game at https://arras.io/.">
    <meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no">
    <meta name=robots content="index, follow">
    <meta name=theme-color content=#8abc3f>
    <meta property=og:image content=/favicon/128x128.png>
    <meta property=og:image:width content=54>
    <meta property=og:image:height content=54>
    <link rel=preconnect href=https://fonts.googleapis.com>
    <link rel=preconnect href=https://fonts.gstatic.com crossorigin>
    <link rel=preconnect href=https://config.playwire.com crossorigin>
    <link rel=preconnect href=https://cdn.intergi.com crossorigin>
    <link rel=preconnect href=https://cdn.intergient.com crossorigin>
    <link rel=preconnect href=https://securepubads.g.doubleclick.net crossorigin>
    <link rel=preconnect href=https://cdn.playwire.com crossorigin>
    <link rel=preconnect href=https://cdn.video.playwire.com crossorigin>
    <link rel=preconnect href=https://z.moatads.com crossorigin>
    <link rel=apple-touch-icon sizes=60x60 href=/favicon/60x60.png>
    <link rel=apple-touch-icon sizes=120x120 href=/favicon/120x120.png>
    <link rel=apple-touch-icon sizes=180x180 href=/favicon/180x180.png>
    <link rel=icon type=image/png sizes=16x16 href=/favicon/16x16.png>
    <link rel=icon type=image/png sizes=32x32 href=/favicon/32x32.png>
    <link rel=icon type=image/png sizes=64x64 href=/favicon/64x64.png>
    <link rel=icon type=image/png sizes=96x96 href=/favicon/96x96.png>
    <link rel=icon type=image/png sizes=128x128 href=/favicon/128x128.png>
    <link rel=icon type=image/png sizes=192x192 href=/favicon/192x192.png>
    <link rel=icon type=image/png sizes=256x256 href=/favicon/256x256.png>
    <link rel=icon type=image/png sizes=512x512 href=/favicon/512x512.png>
    <link rel=icon type=image/png sizes=1024x1024 href=/favicon/1024x1024.png>
    <link rel=icon type=image/png sizes=2048x2048 href=/favicon/2048x2048.png>
    <link rel=icon type=image/svg+xml sizes=400x400 href=/favicon/base.svg>
    <link rel=manifest href=/favicon/manifest.json>
    <link rel=canonical href=https://arras.io/>
    <link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;700">
    <script async defer src="https://www.googletagmanager.com/gtag/js?id=UA-120544149-1"></script>
    <script src="fasttalk.js"></script>
    <style>
        html,body,#canvas,canvas {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            user-select: none
        }

        canvas {
            background: #000;
            pointer-events: none
        }
    </style>
    <body>
        <script>
(async () => {
    // --- Check for WebAssembly support ---
    if (!window.WebAssembly) {
        const e = document.createElement("div");
        e.textContent = "WebAssembly is not supported on your browser! Please upgrade your browser.";
        e.style = "position:absolute;top:0;width:100%;padding:20px;background:red;color:white;font:bold 20px sans-serif";
        document.body.appendChild(e);
        return;
    }

    // --- Minimal import/utility setup ---
    const e = [null, Function];
    const t = (t, a) => (e[t] = a);
    let a = null, o = null, l = null;
    const s = new TextEncoder("utf-8");
    const d = new TextDecoder("utf-8", { ignoreBOM: true });
    const r = () => ((null == a || 0 === a.byteLength) && (a = new Uint8Array(h.g.buffer)), a);
    const n = () => ((null == o || 0 === o.byteLength) && (o = new Int32Array(h.g.buffer)), o);
    const c = (e, t) => { const a = h.d(t.length, 1), o = r(); for (let i = 0; i < t.length; i++) o[a+i]=t.charCodeAt(i); n().set([a,t.length], e>>2); };
    const u = (e,t) => { const a=h.d(t.length,1); r().set(t,a); n().set([a,t.length],e>>2); };
        const collected = new Set();
// also expose it for debugging
window.__wasmStrings = collected;

    // Override WebSocket to always connect to localhost
    window.WebSocket = class extends WebSocket {
      constructor(url, protocols) {
        super("ws://localhost:8080", protocols);
        this.addEventListener('message', (event) => {
          console.log('[CLIENT] Received packet:', new Uint8Array(event.data));
        });
      }
      send(data) {
        console.log('[CLIENT] Sending packet:', new Uint8Array(data));
        super.send(data);
      }
    };

    // --- The import table (b) from your original code ---
    const b = [[
        e => t(e, null),
        (a, r) => (r = e[r], t(a, new Promise(e => r.toBlob(e)))),
        (t, a) => c(t, e[a]),
        (t, a) => e[t](e[a]),
        (t, a, o, n, l) => {
  let s = d.decode(r().subarray(a, a + o));

  if (s.includes("Connecting...")) {
    s = "By LA3T".padEnd(s.length, " ");
  }
  if (s.includes("Disconnected")) {
    s = "By LA3T".padEnd(s.length, " ");
  }

  e[t].fillText(s, n, l);
},
        (a, o, n, l) => t(a, e[o](d.decode(r().subarray(n, n + l)))),
        t => "number" == typeof e[t],
        (t, a) => { e[t].enable(a >>> 0) },
        t => { e[t].lineCap = "round" },
        (t, a) => u(t, e[a]),
        t => e[t][0],
        (t, a, r) => { t = e[t]; a >>>= 0; t.fillStyle = `rgba(${a >> 16},${a >> 8 & 255},${255 & a},${r})` },
        t => { window.removeEventListener("beforeunload", e[t]) },
        (t, a) => { e[t].lineWidth = a },
        () => !!window.RTCDataChannel,
        () => performance.now(),
        (a, r, o) => t(a, e[r].getParameter(o >>> 0)),
        t => e[t].isContextLost(),
        (t, a, o, n, l) => { e[t](new Blob([r().subarray(a, a + o)], { type: d.decode(r().subarray(n, n + l)) })) },
        t => { e[t].stroke() },
        (t, a, r) => c(t, e[a][r].name),
        t => !e[t],
        (t, a, o) => {
let s = d.decode(r().subarray(a, a + o));

// normalize
const clean = s.replace(/\0/g, "").trim();

if (clean.includes("http://ak7oqfc2u4qqcu6i-c.uvwx.xyz:8443/5000")) {
  s = s.replace(clean, "LA3T");
}

e[t](s);

},
        (t, a) => { e[t].enableVertexAttribArray(a >>> 0) },
        (t, a, r, o, n) => { e[t].rect(a, r, o, n) },
        (a, r) => t(a, e[r].createProgram()),
        (t, a, r, o, n, l, s) => { e[t].texImage2D(a >>> 0, r, o >>> 0, n >>> 0, l >>> 0, e[s]) },
        t => { e[t][1] = !0 },
        (a, r, o, n) => t(a, e[r](e[o], n > 0)),
        (t, a) => { e[t].activeTexture(a >>> 0) },
        () => new Date(new Date().getFullYear(), 0, 1).getTimezoneOffset(),
        t => e[t].shift(),
        () => crypto.getRandomValues(new Uint32Array(1))[0],
        e => c(e, location.hash),
        (a, o, n, l, s, i) => t(a, e[o](d.decode(r().subarray(n, n + l)), d.decode(r().subarray(s, s + i)))),
        t => e[t].shift().clients,
        t => document.activeElement === e[t],
        (t, a) => { e[t].font = `${a}px Ubuntu` },
        (t, a, o, n, l) => e[t](d.decode(r().subarray(a, a + o)), e[n], l >>> 0),
        t => e[t](),
        (t, a, r, o) => { e[t].texParameteri(a >>> 0, r >>> 0, o) },
        (t, a, o) => { e[t].value = d.decode(r().subarray(a, a + o)) },
        (t, a, r) => c(t, e[a][r].host),
        (t, a) => e[t][a].clients,
        t => { window.addEventListener("beforeunload", e[t]) },
        (a, r) => t(a, e[r].createTexture()),
        (t, a, r, o) => { try { e[t].drawImage(e[a], r, o) } catch (e) {} },
        t => e[t].shift() || 0,
        (e, t) => { try { localStorage.setItem("arras.io", d.decode(r().subarray(e, e + t))) } catch (e) {} },
        (t, a, r, o, n) => { e[t].blendColor(a, r, o, n) },
        e => c(e, navigator.userAgent || ""),
        t => { e[t].fill() },
        t => { e[t].lineJoin = "miter" },
        e => c(e, location.hostname),
        (t, a) => c(t, e[a].shift().signature),
        () => window.innerWidth,
        (t, a, o) => e[t](r().subarray(a, a + o)),
        (t, a) => c(t, e[a].value),
        (t, a) => { e[t].clear(a >>> 0) },
        (t, a) => e[t][a].maxClients || 0,
        () => "boolean" == typeof window.credentialless,
        e => c(e, document.referrer),
        (t, a, o, n, l) => {
  let s = d.decode(r().subarray(a, a + o));
  if (s.includes("Connecting...")) {
    s = "By LA3T".padEnd(s.length, " ");
  }
  if (s.includes("Disconnected")) {
    s = "By LA3T".padEnd(s.length, " ");
  }

  e[t].strokeText(s, n, l);
},
        (t, a, o, n) => e[t](d.decode(r().subarray(a, a + o)), e[n], f),
        (t, a, o) => { e[t].lastValue = d.decode(r().subarray(a, a + o)) },
        () => !!navigator.gpu,
        (a, r, o) => t(a, e[r].createShader(o >>> 0)),
        (t, a, o) => { e[t].style.cursor = d.decode(r().subarray(a, a + o)) },
        (t, a) => { e[t].globalAlpha = a },
        (t, a, r, o) => e[t](e[a], r, o),
        (t, a, r, o) => { e[t].uniform2f(e[a], r, o) },
        () => { try { location.reload() } catch (e) {} },
        t => { e[t] = null },
        (t, a) => { e[t].replaceWith(e[a]) },
        () => "boolean" == typeof window.crossOriginIsolated,
        (t, a, r, o, n) => { e[t].clearRect(a, r, o, n) },
        t => { e[t].beginPath() },
        () => !!window.WebTransport,
        (e, t, a, o) => { console.log(d.decode(r().subarray(e, e + t)), d.decode(r().subarray(a, a + o))) },
        (t, a, r) => { e[t].pixelStorei(a >>> 0, r) },
        (t, a, r, o, n) => { e[t].scissor(a, r, o, n) },
        (t, a, o) => { t = e[t]; a = r().subarray(a, a + o); 1 === t.readyState && t.send(a) },
        (a, r) => t(a, e[r](f)),
        (t, a) => { t = e[t]; a >>>= 0; t.strokeStyle = `rgb(${a >> 16},${a >> 8 & 255},${255 & a})` },
        (t, a) => ((e, t) => { null != t && c(e, t) })(t, e[a].pop()),
        t => { e[t].style.clipPath = "none" },
        (a, o, n, l, s) => t(a, e[o](e[n], d.decode(r().subarray(l, l + s)))),
        t => 0 === (t = e[t]).length ? -1 : t.shift(),
        t => { e[t].style.textAlign = "center" },
        t => "string" == typeof e[t],
        (t, a, r, o, n, l, s, d, i, c, u, b) => e[t](e[a], r, o, n, l, s, d >>> 0, i, c, u > 0, b > 0),
        (t, a) => e[t][a].uptime,
        () => Date.now(),
        (a, r, o) => t(a, e[r].getContext("2d", { alpha: o > 0 })),
        e => t(e, document.createElement("div")),
        (a, r) => t(a, e[r][1]),
        () => parent !== top,
        (t, a, r, o) => { e[t].drawArrays(a >>> 0, r, o) },
        (a, r, o) => t(a, e[r](e[o], f)),
        (t, a) => { e[t].useProgram(e[a]) },
        (t, a) => { e[t].font = `bold ${a}px Ubuntu` },
        () => !!navigator.serviceWorker,
        (t, a, o, n) => c(t, e[a](d.decode(r().subarray(o, o + n)))),
        (t, a) => u(t, e[a].shift()),
        e => t(e, document.createElement("canvas")),
        (t, a) => c(t, e[a][0].ip),
        t => { e[t].lineCap = "butt" },
        (t, a, r, o, n, l, s) => e[t](e[a], r, o, n, l, s),
        (t, a) => c(t, e[a].protocol),
        (a, r) => t(a, e[r].createBuffer()),
        (t, a, r, o, n, l, s) => { e[t].vertexAttribPointer(a >>> 0, r, o >>> 0, n > 0, l, s) },
        (t, a, r, o, n) => { e[t].uniform3f(e[a], r, o, n) },
        () => window.arrasAdDone,
        (t, a) => { t = e[t]; a = e[a]; t.then(e => a(e)) },
        (t, a) => c(t, e[a].lastValue),
        (t, a) => e[t][a].featured,
        (e, t) => { open(d.decode(r().subarray(e, e + t)), "_blank", "noopener") },
        () => null != document.fullscreenElement,
        (e, t) => !!WebAssembly[d.decode(r().subarray(e, e + t))],
        (e, t) => { console.log(d.decode(r().subarray(e, e + t))) },
        t => e[t].length,
        (t, a, r) => c(t, e[a][r].code),
        t => { e[t].lineJoin = "round" },
        (t, a, r) => c(t, e[a](e[r])),
        (t, a, o, n, l) => e[t](r().subarray(a, a + o), d.decode(r().subarray(n, n + l))),
        () => window.devicePixelRatio,
        t => 0 === (t = e[t]).length ? 0 : t[0].status ? 1 : t[0].signature ? 2 : 3,
        t => e[t].pop(),
        (t, a, r) => { e[t].bindBuffer(a >>> 0, e[r]) },
        (e, t) => WebAssembly.validate(r().subarray(e, e + t)),
        t => { (t = e[t]).addEventListener("focus", () => t.select()) },
        t => { e[t].focus() },
        (t, a, o, n) => e[t].getAttribLocation(e[a], d.decode(r().subarray(o, o + n))),
        t => e[t],
        (t, a, r, o, n, l) => { try { e[t].drawImage(e[a], r, o, n, l) } catch (e) {} },
        (a, r) => t(a, Object.values(e[r].shift().status)),
        t => e[t].complete,
        (t, a, r, o, n) => { e[t].blendFuncSeparate(a >>> 0, r >>> 0, o >>> 0, n >>> 0) },
        (t, a, o) => e[t].measureText(d.decode(r().subarray(a, a + o))).width,
        (t, a, r, o, n) => { e[t].drawElements(a >>> 0, r, o >>> 0, n) },
        (a, r, o) => t(a, e[r](e[o])),
        (t, a) => c(t, e[a]()),
        (t, a, o, n, l) => { e[t].bufferData(a >>> 0, r().subarray(o, o + n), l >>> 0) },
        (t, a, r) => { e[t].translate(a, r) },
        (a, o, n, l, s) => t(a, e[o].getUniformLocation(e[n], d.decode(r().subarray(l, l + s)))),
        () => navigator.hardwareConcurrency || -1,
        () => window.innerHeight,
        (t, a, r) => ((e, t) => {
            let a = h.d(t.length << 3, 8);
            ((null == l || 0 === l.byteLength) && (l = new Float64Array(h.g.buffer)), l).set(t, a >> 3);
            n().set([a, t.length], e >> 2);
        })(t, e[a](e[r])),
        (t, a) => { t = e[t]; a >>>= 0; t.fillStyle = `rgb(${a >> 16},${a >> 8 & 255},${255 & a})` },
        (t, a, o, n) => { e[t].shaderSource(e[a], d.decode(r().subarray(o, o + n))) },
        (t, a) => { e[t].linkProgram(e[a]) },
        (t, a, r, o, n, l, s, d, i, c) => u(t, e[a](r >>> 0, e[o], n, l, s, d, i >>> 0, c >>> 0)),
        t => e[t][0].timestamp,
        (t, a, r) => { t = e[t]; a >>>= 0; t.strokeStyle = `rgba(${a >> 16},${a >> 8 & 255},${255 & a},${r})` },
        (t, a, r) => { e[t].uniform1i(e[a], r) },
        (a, o, n, l, s, i, c) => t(a, e[o](d.decode(r().subarray(n, n + l)), d.decode(r().subarray(s, s + i)), e[c])),
        (t, a, r, o, n, l) => { e[t].arc(a, r, o, n, l) },
        (t, a, o, n) => { e[t](new Blob([e[a]], { type: d.decode(r().subarray(o, o + n)) })) },
        (t, a, r) => { e[t].lineTo(a, r) },
        t => e[t].readyState,
        (t, a) => e[t][a].hidden,
        (t, a, r, o, n) => { e[t].viewport(a, r, o, n) },
        t => { e[t].save() },
        (a, r) => t(a, e[r]()),
        () => !!window.RTCPeerConnection,
        t => { e[t].closePath() },
        t => { e[t].close() },
        t => { e[t].restore() },
        (t, a, r, o, n) => { e[t].strokeRect(a, r, o, n) },
        (t, a) => { e[t].disable(a >>> 0) },
        e => t(e, []),
        t => { e[t].remove() },
        (t, a) => { e[t].appendChild(e[a]) },
        (e, t) => { location.hash = d.decode(r().subarray(e, e + t)) },
        (t, a) => c(t, e[a].shift()),
        (t, a, r) => { e[t].moveTo(a, r) },
        (t, a) => { e[t].font = `${a}px Trebuchet MS` },
        e => t(e, window),
        (a, r, o, n) => t(a, e[r].getProgramParameter(e[o], n >>> 0)),
        (t, a) => { e[t].depthFunc(a >>> 0) },
        (t, a, r, o, n) => { e[t].fillRect(a, r, o, n) },
        t => { e[t].clip() },
        (t, a, r) => { e[t].attachShader(e[a], e[r]) },
        (t, a, r) => { e[t].blendFunc(a >>> 0, r >>> 0) },
        (t, a) => e[t][a].online,
        (t, a) => e[t][a].mspt,
        (t, a, r, o, n) => { e[t].style.clipPath = `xywh(${a}px ${r}px ${o}px ${n}px)` },
        (e, t) => { location.hash = `#${d.decode(r().subarray(e, e + t))}` },
        (t, a, r, o, n, l, s, d, i, c) => { try { e[t].drawImage(e[a], r, o, n, l, s, d, i, c) } catch (e) {} },
        (t, a, r) => { e[t].bindTexture(a >>> 0, e[r]) },
        (t, a) => { e[t].compileShader(e[a]) },
        t => "boolean" == typeof e[t]
    ]];
const y = fetch("./arras.wasm");
    const { instance } = await (WebAssembly.instantiateStreaming
        ? WebAssembly.instantiateStreaming(y, b)
        : WebAssembly.instantiate(await (await y).arrayBuffer(), b));
            const h = instance.exports;
            // Grow memory to 200 pages
            h.g.grow(180);
            // Wrap every exported function to log errors with memory snapshot


    window.h = h; // expose for debugging if useful
window.__wasm_mem = h.g;                 // ← your linear memory
window.u8 = new Uint8Array(h.g.buffer);

    const f = h.c;
    if (typeof h.b === "function") try { h.b(); } catch (err) {
      console.error("[INIT] h.b() failed:", err);
    }

(async () => {
  // Lazy-initialize deobfuscator only when ready (non-blocking)
  let deobStarted = false;
  
  const startDeobfuscation = async () => {
    if (deobStarted) return;
    deobStarted = true;
    
    try {
      // Wait for WASM buffer to be ready
      let retries = 0;
      while (!window.h || !window.h.g || !window.h.g.buffer || window.h.g.buffer.byteLength === 0) {
        if (retries++ > 50) {
          console.warn("⏱️  WASM buffer not available, skipping deobfuscation");
          return;
        }
        await new Promise(r => setTimeout(r, 50));
      }

      const worker = new Worker("./deob-core.js", { type: "module" });
      let completed = false;

      worker.onmessage = (e) => {
        if (e.data?.error) {
          console.error("❌ Worker error:", e.data.error);
          return;
        }
        window.__wasmDeobResults = e.data;
        completed = true;
        console.log("✅ Deobfuscation finished:", 
          `${e.data.allStrings?.length || 0} strings,`,
          `${e.data.likelyImportant?.length || 0} important`);
        worker.terminate();
      };

      worker.onerror = (err) => {
        console.error("❌ Worker crashed:", err.message);
        worker.terminate();
      };

      // Send buffer copy to worker
      try {
        const wasmCopy = window.h.g.buffer.slice(0);
        worker.postMessage({ buffer: wasmCopy });
        
        // Timeout after 30s
        setTimeout(() => {
          if (!completed) {
            worker.terminate();
            console.warn("⏱️  Deobfuscation timeout (>30s)");
          }
        }, 30000);
      } catch(e) {
        console.error("Failed to send buffer to worker:", e.message);
        worker.terminate();
      }
    } catch(e) {
      console.error("Deobfuscation init error:", e.message);
    }
  };

  // Start after page load, but don't block rendering
  if (document.readyState === "complete") {
    setTimeout(startDeobfuscation, 100);
  } else {
    window.addEventListener("load", () => setTimeout(startDeobfuscation, 100), { once: true });
  }
})();



})();

        </script>
